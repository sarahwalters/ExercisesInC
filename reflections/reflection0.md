## Reflection 0 -- team formation & first sprint backlog

For me, team formation was mostly about finding people I know I’d be happy working with -- my class-related interests are broad enough that I was pretty sure I’d enjoy any project with a good team. I think much of the rest of my team felt similarly. We decided on a project by researching and proposing three project ideas each and then choosing our collective favorite (paying attention to individual learning goals). Individually: I took a computer graphics class at Wellesley last semester and am interested in continuing to explore that field, I’d like to thoroughly understand the basics of multithreading / concurrency, and I’d like to learn more about network programming & network protocols. The project we settled on addresses two out of three of those goals: we’re building a Rubik’s cube solver with a graphical visualization which might rely on some sort of concurrent tree-based algorithm (maybe not for the 3x3 case, but if we generalize to solve larger cubes).

It wasn’t difficult to decide on a scrum master -- multiple people volunteered, and Philip seemed most enthusiastic. Our goal for this sprint is to set up the basis for really solid integration -- we want to make sure to design the visualization of the Rubik’s cube and the logic which represents and solves the cube so they “talk to” each other via a simple & clean interface. We broke the work we need to do to get to that goal into tasks which will take one person 1-2 days, and we represented those tasks as individual Trello cards or as items in a checklist on an overarching card. (I think maybe we have a bit of work to do to formalize our scrum process, depending on how this sprint feels). From this sprint, we omitted goals which aren’t directly related to that solid basis for integration -- we’ll be able to tackle those in future sprints.

I’m a little apprehensive about gluing the C++ graphics code to C logic code, if that’s something we end up deciding to do. I don’t know enough about either language to understand how exactly the communication between the logic and the interface will look. I think we’re taking the right steps to mitigate that apprehension, though -- we’re addressing it in the first sprint.
